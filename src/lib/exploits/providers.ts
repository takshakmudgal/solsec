import { env } from "~/env";
import { logger } from "~/lib/logger";
import type { Exploit } from "@prisma/client";
import { Flipside } from "@flipsidecrypto/sdk";

export interface ExploitDataProvider {
  fetchLatestExploits(): Promise<Partial<Exploit>[]>;
  name: string;
}

export class FlipsideProvider implements ExploitDataProvider {
  name = "Flipside";
  private flipside: Flipside;

  constructor() {
    const apiKey = env.FLIPSIDE_API_KEY;

    if (!apiKey) {
      throw new Error("FLIPSIDE_API_KEY is required for FlipsideProvider");
    }

    this.flipside = new Flipside(apiKey, "https://api-v2.flipsidecrypto.xyz");

    logger.info("FlipsideProvider initialized");
  }

  async fetchLatestExploits(): Promise<Partial<Exploit>[]> {
    try {
      logger.info("Fetching latest exploits from Flipside");

      const sql = `
        WITH exploit_events AS (
          SELECT 
            program_id as protocol,
            block_timestamp as hack_date,
            total_value_usd as amount_stolen_usd,
            CASE
              WHEN error_message LIKE '%overflow%' THEN 'Arithmetic Error'
              WHEN error_message LIKE '%authorization%' THEN 'Authorization Bypass'
              WHEN error_message LIKE '%oracle%' THEN 'Oracle Manipulation'
              WHEN signatures > 10 THEN 'Flash Loan Attack' 
              ELSE 'Unknown Exploit'
            END as exploit_type,
            error_message as technique,
            signer as related_entity,
            false as recovered,
            null as resolution,
            null as audited_by,
            CONCAT('Transaction: ', tx_id, '. Flagged as security incident with ', total_value_usd, ' USD affected.') as notes
          FROM 
            solana.core.fact_transactions
          WHERE 
            (succeeded = false AND error_message IS NOT NULL) 
            OR (total_value_usd > 100000)
          AND
            block_timestamp >= CURRENT_DATE - INTERVAL '30 days'
        )
        
        SELECT 
          protocol,
          hack_date,
          amount_stolen_usd,
          exploit_type,
          technique,
          related_entity,
          recovered,
          resolution,
          audited_by,
          notes
        FROM 
          exploit_events
        ORDER BY 
          hack_date DESC
        LIMIT 100
      `;

      const queryResult = await this.flipside.query.run({
        sql,
        ttlMinutes: 15,
        timeoutMinutes: 2,
        cached: true,
      });

      if (queryResult.error) {
        const errorMessage =
          typeof queryResult.error === "object" &&
          queryResult.error !== null &&
          "message" in queryResult.error
            ? String(queryResult.error.message)
            : JSON.stringify(queryResult.error);
        throw new Error(`Flipside query error: ${errorMessage}`);
      }

      logger.info(
        `Flipside query successful, received ${queryResult.records?.length ?? 0} records`,
      );

      return (queryResult.records ?? []).map((rowRecord) => {
        const row = rowRecord as Record<string, unknown>;

        const protocol =
          typeof row.protocol === "string" ? row.protocol : "Unknown Protocol";
        const hackDateRaw = row.hack_date;
        const hackDate =
          typeof hackDateRaw === "string" ||
          typeof hackDateRaw === "number" ||
          hackDateRaw instanceof Date
            ? new Date(hackDateRaw)
            : new Date();
        const amountStolenRaw = row.amount_stolen_usd;
        const amountStolen =
          typeof amountStolenRaw === "string" ||
          typeof amountStolenRaw === "number"
            ? parseFloat(String(amountStolenRaw))
            : 0;
        const exploitType =
          typeof row.exploit_type === "string"
            ? row.exploit_type
            : "Unknown Exploit";
        const technique =
          typeof row.technique === "string" ? row.technique : "Unknown";
        const relatedEntity =
          typeof row.related_entity === "string" ? row.related_entity : null;

        let recovered = false;
        const recoveredRaw = row.recovered;
        if (typeof recoveredRaw === "string") {
          recovered = recoveredRaw.toLowerCase() === "true";
        } else if (typeof recoveredRaw === "boolean") {
          recovered = recoveredRaw;
        }

        const resolution =
          typeof row.resolution === "string" ? row.resolution : null;
        const auditedBy =
          typeof row.audited_by === "string" ? row.audited_by : null;
        const notes =
          typeof row.notes === "string"
            ? row.notes
            : `Detected by FlipsideProvider at ${new Date().toISOString()}`;

        const result: Partial<Exploit> = {
          protocol,
          hackDate,
          amountStolen,
          exploitType,
          technique,
          relatedEntity,
          recovered,
          resolution,
          auditedBy,
          notes,
        };
        return result;
      });
    } catch (error) {
      logger.error("Error fetching exploits from Flipside", { error });
      throw error;
    }
  }
}

interface HeliusEvent {
  programName?: string;
  timestamp?: string | number | Date;
  totalValueLost?: number;
  eventType?: string;
  description?: string;
  attackerAddress?: string;
  signature?: string;
}

interface HeliusError {
  message?: string;
}

// Define a type for the expected response structure
// It could be an array of events or an object with an error property
type HeliusResponse = HeliusEvent[] | { error: HeliusError | string };

export class HeliusProvider implements ExploitDataProvider {
  name = "Helius";
  private apiKey: string;
  private endpoint: string;

  constructor() {
    const apiKey = env.HELIUS_API_KEY;

    if (!apiKey) {
      throw new Error("HELIUS_API_KEY is required for HeliusProvider");
    }

    this.apiKey = apiKey;
    this.endpoint = "https://api.helius.xyz/v1";
    logger.info("HeliusProvider initialized");
  }

  async fetchLatestExploits(): Promise<Partial<Exploit>[]> {
    try {
      logger.info("Fetching latest exploits from Helius");

      const response = await fetch(
        `${this.endpoint}/security-events?api-key=${this.apiKey}`,
        {
          method: "GET",
          headers: {
            "Content-Type": "application/json",
          },
        },
      );

      if (!response.ok) {
        throw new Error(
          `Helius API error: ${response.status} ${response.statusText}`,
        );
      }

      const data: HeliusResponse = (await response.json()) as HeliusResponse;

      if (
        typeof data === "object" &&
        data !== null &&
        "error" in data &&
        data.error
      ) {
        const errorObj = data.error;
        const errorMessage =
          typeof errorObj === "object" &&
          errorObj !== null &&
          "message" in errorObj &&
          errorObj.message
            ? errorObj.message
            : JSON.stringify(errorObj);
        throw new Error(`Helius API error: ${errorMessage}`);
      }

      if (!Array.isArray(data)) {
        throw new Error("Helius API response was not an array of events");
      }

      logger.info(
        `Helius query successful, received ${data.length ?? 0} events`,
      );

      return (data ?? []).map((event: HeliusEvent) => {
        const today = new Date();

        const protocol = event.programName ?? "Unknown Protocol";

        const hackDateRaw = event.timestamp;
        let hackDate = today;
        if (
          hackDateRaw &&
          (typeof hackDateRaw === "string" ||
            typeof hackDateRaw === "number" ||
            hackDateRaw instanceof Date)
        ) {
          try {
            hackDate = new Date(hackDateRaw);
            if (isNaN(hackDate.getTime())) {
              hackDate = today;
              logger.warn("Invalid date format received from Helius", {
                timestamp: hackDateRaw,
              });
            }
          } catch (e) {
            hackDate = today;
            logger.warn("Error parsing date from Helius", {
              timestamp: hackDateRaw,
              error: e,
            });
          }
        }

        const amountStolen =
          typeof event.totalValueLost === "number" ? event.totalValueLost : 0;
        const exploitType = event.eventType ?? "Unknown Exploit";
        const technique = event.description ?? "Unknown Technique";
        const relatedEntity = event.attackerAddress ?? null;
        const signature = event.signature ?? "Unknown";

        const result: Partial<Exploit> = {
          protocol,
          hackDate,
          amountStolen,
          exploitType,
          technique,
          relatedEntity,
          recovered: false,
          resolution: null,
          auditedBy: null,
          notes: `Transaction: ${signature}. Flagged as potential security incident.`,
        };
        return result;
      });
    } catch (error) {
      logger.error("Error fetching exploits from Helius", { error });
      throw error;
    }
  }
}

export function getExploitDataProvider(): ExploitDataProvider {
  const providerType = env.EXPLOIT_DATA_PROVIDER?.toLowerCase() || "flipside";

  try {
    switch (providerType) {
      case "flipside":
        return new FlipsideProvider();
      case "helius":
        return new HeliusProvider();
      default:
        logger.warn(
          `Unknown provider type '${providerType}', falling back to Flipside`,
        );
        return new FlipsideProvider();
    }
  } catch (error) {
    logger.error(`Failed to initialize ${providerType} provider`, { error });

    try {
      if (providerType === "flipside") {
        logger.info("Falling back to Helius provider");
        return new HeliusProvider();
      } else {
        logger.info("Falling back to Flipside provider");
        return new FlipsideProvider();
      }
    } catch (fallbackError) {
      logger.error("Both providers failed to initialize", { fallbackError });
      throw new Error("Failed to initialize any data provider");
    }
  }
}
