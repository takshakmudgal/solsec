import { db } from "~/server/db";
import { logger } from "~/lib/logger";
import { getExploitDataProvider } from "~/lib/exploits/providers";
import { env } from "~/env";
import type { Exploit } from "@prisma/client";

export class ExploitPollingService {
  private pollIntervalMs: number;
  private intervalId: NodeJS.Timeout | null = null;
  private provider = getExploitDataProvider();
  private isPolling = false;

  constructor() {
    this.pollIntervalMs = (env.EXPLOIT_POLL_INTERVAL || 15) * 60 * 1000;
    logger.info(
      `Initialized ExploitPollingService with ${this.provider.name} provider, polling every ${env.EXPLOIT_POLL_INTERVAL} minutes`,
    );
  }

  start(): void {
    if (this.intervalId) {
      logger.warn(
        "ExploitPollingService already running, ignoring start request",
      );
      return;
    }

    logger.info("Starting ExploitPollingService");

    void this.pollExploits();

    this.intervalId = setInterval(() => {
      void this.pollExploits();
    }, this.pollIntervalMs);
  }

  stop(): void {
    if (!this.intervalId) {
      logger.warn("ExploitPollingService not running, ignoring stop request");
      return;
    }

    logger.info("Stopping ExploitPollingService");
    clearInterval(this.intervalId);
    this.intervalId = null;
  }

  async forcePoll(): Promise<Exploit[]> {
    return this.pollExploits();
  }

  private async pollExploits(): Promise<Exploit[]> {
    if (this.isPolling) {
      logger.info("Poll already in progress, skipping");
      return [];
    }

    this.isPolling = true;
    const startTime = Date.now();
    const newExploits: Exploit[] = [];

    try {
      logger.info(`Polling for exploits from ${this.provider.name}...`);

      const exploitData = await this.provider.fetchLatestExploits();

      if (exploitData.length === 0) {
        logger.info("No new exploits found");
        return [];
      }

      logger.info(
        `Found ${exploitData.length} potential exploits, checking for new ones...`,
      );

      for (const exploit of exploitData) {
        if (!exploit.protocol || !exploit.hackDate) {
          logger.warn("Skipping exploit with missing protocol or hackDate", {
            exploit,
          });
          continue;
        }

        try {
          const existingExploit = await db.exploit.findFirst({
            where: {
              protocol: exploit.protocol,
              hackDate: exploit.hackDate,
            },
          });

          let result: Exploit;

          if (existingExploit) {
            result = await db.exploit.update({
              where: {
                id: existingExploit.id,
              },
              data: {
                amountStolen:
                  exploit.amountStolen ?? existingExploit.amountStolen,
                recovered: exploit.recovered ?? existingExploit.recovered,
                resolution: exploit.resolution ?? existingExploit.resolution,
                auditedBy: exploit.auditedBy ?? existingExploit.auditedBy,
                notes: exploit.notes ?? existingExploit.notes,
              },
            });
            logger.info(
              `Updated existing exploit: ${result.protocol} (${result.hackDate.toISOString().split("T")[0]})`,
            );
          } else {
            result = await db.exploit.create({
              data: {
                protocol: exploit.protocol,
                hackDate: exploit.hackDate,
                amountStolen: exploit.amountStolen!,
                exploitType: exploit.exploitType!,
                technique: exploit.technique!,
                relatedEntity: exploit.relatedEntity,
                recovered: exploit.recovered!,
                resolution: exploit.resolution,
                auditedBy: exploit.auditedBy,
                notes: exploit.notes,
              },
            });
            newExploits.push(result);
            logger.info(
              `Added new exploit: ${result.protocol} (${result.hackDate.toISOString().split("T")[0]})`,
            );
          }
        } catch (error) {
          logger.error(`Error processing exploit ${exploit.protocol}`, {
            error,
            exploit,
          });
        }
      }

      const timeElapsed = Date.now() - startTime;
      logger.info(
        `Exploit polling completed in ${timeElapsed}ms. Added ${newExploits.length} new exploits.`,
      );

      return newExploits;
    } catch (error) {
      logger.error("Exploit polling failed", { error });
      return [];
    } finally {
      this.isPolling = false;
    }
  }
}

export const exploitPollingService = new ExploitPollingService();
