import { createTRPCRouter, publicProcedure } from "../trpc";
import { db } from "~/server/db";
import { z } from "zod";
import { exploitPollingService } from "~/lib/exploits/polling";
import { logger } from "~/lib/logger";
import { TRPCError } from "@trpc/server";

export const exploitsRouter = createTRPCRouter({
  getSolanaExploits: publicProcedure.query(async () => {
    try {
      const exploits = await db.exploit.findMany({
        orderBy: {
          hackDate: "desc",
        },
      });

      return exploits;
    } catch (error) {
      logger.error("Error fetching Solana exploits from DB:", { error });
      throw new TRPCError({
        code: "INTERNAL_SERVER_ERROR",
        message: "Failed to fetch exploit data from database",
        cause: error,
      });
    }
  }),

  getExploitById: publicProcedure
    .input(
      z.object({
        id: z.string(),
      }),
    )
    .query(async ({ input }) => {
      try {
        const exploit = await db.exploit.findUnique({
          where: { id: input.id },
        });

        if (!exploit) {
          throw new TRPCError({
            code: "NOT_FOUND",
            message: "Exploit not found",
          });
        }

        return exploit;
      } catch (error) {
        logger.error("Error fetching exploit by ID:", { error, id: input.id });

        if (error instanceof TRPCError) {
          throw error;
        }

        throw new TRPCError({
          code: "INTERNAL_SERVER_ERROR",
          message: "Failed to fetch exploit details",
          cause: error,
        });
      }
    }),

  addExploit: publicProcedure
    .input(
      z.object({
        protocol: z.string().min(1),
        hackDate: z.string().transform((val) => new Date(val)),
        amountStolen: z.number().positive(),
        exploitType: z.string().min(1),
        technique: z.string().min(1),
        relatedEntity: z.string().optional().nullable(),
        recovered: z.boolean(),
        resolution: z.string().optional().nullable(),
        auditedBy: z.string().optional().nullable(),
        notes: z.string().optional().nullable(),
      }),
    )
    .mutation(async ({ input }) => {
      try {
        const existingExploit = await db.exploit.findFirst({
          where: {
            protocol: input.protocol,
            hackDate: input.hackDate,
          },
        });

        if (existingExploit) {
          throw new TRPCError({
            code: "CONFLICT",
            message: `An exploit for ${input.protocol} on ${input.hackDate.toISOString().split("T")[0]} already exists`,
          });
        }

        const newExploit = await db.exploit.create({
          data: input,
        });

        logger.info(`Manually added new exploit: ${newExploit.protocol}`, {
          id: newExploit.id,
        });
        return newExploit;
      } catch (error) {
        logger.error("Error adding exploit:", { error, input });

        if (error instanceof TRPCError) {
          throw error;
        }

        throw new TRPCError({
          code: "INTERNAL_SERVER_ERROR",
          message: "Failed to add new exploit to database",
          cause: error,
        });
      }
    }),

  startPolling: publicProcedure.mutation(() => {
    try {
      exploitPollingService.start();
      return { success: true, message: "Exploit polling service started" };
    } catch (error) {
      logger.error("Error starting exploit polling service:", { error });
      throw new TRPCError({
        code: "INTERNAL_SERVER_ERROR",
        message: "Failed to start exploit polling service",
        cause: error,
      });
    }
  }),

  stopPolling: publicProcedure.mutation(() => {
    try {
      exploitPollingService.stop();
      return { success: true, message: "Exploit polling service stopped" };
    } catch (error) {
      logger.error("Error stopping exploit polling service:", { error });
      throw new TRPCError({
        code: "INTERNAL_SERVER_ERROR",
        message: "Failed to stop exploit polling service",
        cause: error,
      });
    }
  }),

  forcePoll: publicProcedure.mutation(async () => {
    try {
      const newExploits = await exploitPollingService.forcePoll();
      return {
        success: true,
        message: `Polled for exploits, found ${newExploits.length} new exploits`,
        newExploits,
      };
    } catch (error) {
      logger.error("Error during force poll:", { error });
      throw new TRPCError({
        code: "INTERNAL_SERVER_ERROR",
        message: "Failed to poll for exploits",
        cause: error,
      });
    }
  }),

  getExploitStats: publicProcedure.query(async () => {
    try {
      const allExploits = await db.exploit.findMany();

      const totalCount = allExploits.length;
      const totalAmountStolen = allExploits.reduce(
        (total, exploit) => total + exploit.amountStolen,
        0,
      );
      const recoveredCount = allExploits.filter((e) => e.recovered).length;
      const recoveryRate =
        totalCount > 0 ? (recoveredCount / totalCount) * 100 : 0;

      const exploitTypes = new Map<string, number>();
      for (const exploit of allExploits) {
        const count = exploitTypes.get(exploit.exploitType) ?? 0;
        exploitTypes.set(exploit.exploitType, count + 1);
      }

      const hacksByMonth = new Map<string, number>();
      for (const exploit of allExploits) {
        const yearMonth = exploit.hackDate.toISOString().substring(0, 7);
        const count = hacksByMonth.get(yearMonth) ?? 0;
        hacksByMonth.set(yearMonth, count + 1);
      }

      return {
        totalCount,
        totalAmountStolen,
        recoveredCount,
        recoveryRate,
        exploitTypes: Object.fromEntries(exploitTypes),
        hacksByMonth: Object.fromEntries(hacksByMonth),
        lastUpdated: new Date(),
      };
    } catch (error) {
      logger.error("Error fetching exploit statistics:", { error });
      throw new TRPCError({
        code: "INTERNAL_SERVER_ERROR",
        message: "Failed to fetch exploit statistics",
        cause: error,
      });
    }
  }),
});
